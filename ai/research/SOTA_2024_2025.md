# SOTA Storage Engine Research (2024-2025)

**Date**: November 19, 2025
**Purpose**: Inform qpdb architecture decisions

---

## Executive Summary

**SOTA for single-file storage**: LeanStore (VLDB 2024) with pointer swizzling

**Best Rust reference**: redb (clean CoW B-tree, ~18K SLOC)

**Recommended approach**: Start with redb-style CoW B-tree, add LeanStore pointer swizzling incrementally

---

## LeanStore (VLDB 2024)

**Paper**: "LeanStore: A High-Performance Storage Engine for NVMe SSDs" - Viktor Leis

**Key Innovation**: Pointer swizzling without hash tables

**Performance**:
- 40-60% buffer pool speedup vs traditional (hash table-based)
- In-memory workload: Near pure in-memory B-tree performance
- Out-of-memory: Smooth degradation, saturates NVMe bandwidth

**Architecture**:
```rust
enum Swip {
    Hot(*mut Page),   // Direct pointer (O(1))
    Cold(u64),        // Disk offset (I/O required)
}
```

**Status**: Active research, 1,068 commits, latest work on autonomous commits (SIGMOD 2025)

**Repository**: `github.com/leanstore/leanstore` (C++, research prototype)

---

## ScaleCache (VLDB 2025)

**Paper**: "ScaleCache: Scalable and Production-grade Buffer Management"

**Innovations**:
- Per-group buffer reference counting (scalable pinning)
- SIMD-accelerated hash table for page-to-buffer translation
- Novel RW lock based on copy-on-write

**Status**: Production-grade (Huawei), targets many-core servers

**Relevance**: Alternative to pointer swizzling, more complex

---

## redb (Rust Reference)

**Repository**: `github.com/cberner/redb`

**Architecture**: Copy-on-write B-trees, MVCC, ACID

**Size**: ~18K SLOC

**Maturity**: 66 releases, actively maintained (latest: Sep 2025)

**Key Features**:
- Zero-copy reads
- Crash-safe by design
- Multiple concurrent readers + single writer
- Savepoints for partial rollback

**Why Study**: Clean, well-designed Rust B-tree implementation

**Files to Read**:
- `docs/design.md` - Architecture
- `src/tree/btree.rs` - Core B-tree
- `src/transaction.rs` - MVCC
- `tests/` - Correctness tests

---

## Other Rust DBs

**Limbo** (Dec 2024):
- SQLite rewrite in Rust by Turso
- Too early/complex for reference (full SQL layer)

**sled**:
- Lock-free B-tree
- Less active development
- Complex, harder to learn from

**hiqlite**, **VelarixDB**:
- Distributed/LSM focus
- Not relevant for single-file B-tree

---

## Recommended Architecture

### Phase 1: redb-style Foundation
- Copy-on-write B-tree
- MVCC for concurrent reads
- WAL for crash recovery
- Tokio for cross-platform I/O

**Why**: Proven, simpler than pointer swizzling, good foundation

### Phase 2: LeanStore Innovations
- Pointer swizzling (Swip enum)
- Buffer pool with CLOCK eviction
- Page table (PageID â†’ Swip mapping)

**Why**: 40-60% speedup, validated in research

### Phase 3: Optimizations
- Optimistic Lock Coupling (OLC)
- SIMD key comparison
- Variable-size pages
- Compression

**Why**: Production-grade performance

---

## Key Design Decisions

**Rust over Mojo**:
- Stability (Mojo v0.25 nightly vs Rust stable)
- Ecosystem (mature crates vs build-from-scratch)
- Production readiness

**CoW B-tree before pointer swizzling**:
- Simpler, proven in redb
- Good foundation for later optimization
- Easier to get correct first

**Tokio over io_uring**:
- Cross-platform (macOS + Linux)
- Simpler API
- Good enough for single-file workloads
- Can add io_uring later (optional backend)

**B+-tree over LSM-tree**:
- Single-file storage
- Read-optimized workloads
- Complements LSM-based seerdb

---

## Performance Targets

**Phase 1 (CoW B-tree)**:
- Baseline: Working correctness
- Validate: Property tests, crash recovery

**Phase 2 (Pointer swizzling)**:
- Target: 40-60% speedup over Phase 1
- Validate: In-memory benchmark vs Phase 1 baseline

**Phase 3 (Optimizations)**:
- Compare: SQLite, redb, RocksDB
- Validate: Real workloads (YCSB-like)

---

## References

**LeanStore**:
- VLDB 2024 paper (primary)
- SIGMOD 2025 (autonomous commits)
- VLDB 2023 (snapshot isolation)

**redb**:
- `docs/design.md`
- Source code study

**VLDB 2025**:
- ScaleCache (buffer management)
- Indirection Skipping (direct access paths)
